import { Injectable } from '@angular/core';
import {DistanceService} from "../distance.service";

@Injectable({
  providedIn: 'root'
})
export class AntColonyService {
  private pheromones: number[][] = [];  // Initialize as an empty array
  public alpha: number = 1;  // Importance of pheromone
  public beta: number = 2;   // Importance of distance
  public evaporationRate: number = 0.5;
  public antCount: number = 10;  // Number of ants to simulate
  public iterations: number = 100;  // Number of iterations for optimization

  constructor(private distanceService: DistanceService) {}

  // Main method to calculate the route using the ACO algorithm
  calculateAntColonyRoute(locations: [number, number][]): [number, number][] {
    const startTime = performance.now(); // Start time for performance measurement
    let distanceCalculations = 0; // Count the number of distance calculations
    const numLocations = locations.length; // Number of locations
    this.initializePheromones(numLocations);

    let bestRoute: [number, number][] = [];
    let bestDistance = Infinity;

    for (let iteration = 0; iteration < this.iterations; iteration++) {
      const allRoutes: [number, number][][] = [];

      for (let ant = 0; ant < this.antCount; ant++) {
        const route = this.constructSolution(locations, distanceCalculations);
        const distance = this.calculateTotalDistance(route, distanceCalculations);
        distanceCalculations += numLocations - 1; // Update the count for each ant route calculation

        if (distance < bestDistance) {
          bestDistance = distance;
          bestRoute = route;
        }

        allRoutes.push(route);
      }

      this.updatePheromones(allRoutes, locations);
    }

    const endTime = performance.now(); // End time for performance measurement
    const timeTaken = endTime - startTime; // Calculate the time taken

    // Log information
    console.log('Time taken:', timeTaken.toFixed(2), "ms");
    console.log('Nodes used:', numLocations);

    // Ensure the route returns to the starting point
    if (bestRoute.length > 0 && bestRoute[0] !== bestRoute[bestRoute.length - 1]) {
      bestRoute.push(bestRoute[0]); // Append the starting node to the end of the route
    }

    return bestRoute;
  }

  // Initialize pheromone matrix
  private initializePheromones(numLocations: number): void {
    this.pheromones = Array.from({ length: numLocations }, () =>
      Array(numLocations).fill(1)  // Fill pheromone matrix with initial value of 1
    );
  }

  // Construct a solution for an individual ant
  private constructSolution(locations: [number, number][], distanceCalculations: number): [number, number][] {
    const route: [number, number][] = [];
    const unvisited = [...locations];
    let currentLocation = unvisited.shift(); // Start from the first location

    if (currentLocation) {
      route.push(currentLocation);
    }

    while (unvisited.length > 0) {
      const nextLocation = this.selectNextLocation(currentLocation!, unvisited, locations, distanceCalculations);
      route.push(nextLocation);
      currentLocation = nextLocation;
      unvisited.splice(unvisited.indexOf(nextLocation), 1);
    }

    // Ensure that the solution returns to the starting location
    if (route.length > 0 && route[0] !== route[route.length - 1]) {
      route.push(route[0]); // Append the starting node to the end of the route
    }

    return route;
  }

  // Select the next location based on pheromone level and distance
  private selectNextLocation(
    currentLocation: [number, number],
    unvisited: [number, number][],
    locations: [number, number][],
    distanceCalculations: number
  ): [number, number] {
    const probabilities = unvisited.map((location) => {
      const pheromoneLevel = this.getPheromoneLevel(currentLocation, location, locations);
      const distance = this.distanceService.calculateDistance(currentLocation, location);
      distanceCalculations++; // Increment the number of distance calculations
      return Math.pow(pheromoneLevel, this.alpha) * Math.pow(1 / distance, this.beta);
    });

    // Normalize the probabilities and select the next location
    const total = probabilities.reduce((acc, prob) => acc + prob, 0);
    const normalizedProbabilities = probabilities.map((prob) => prob / total);
    const random = Math.random();

    let cumulative = 0;
    for (let i = 0; i < normalizedProbabilities.length; i++) {
      cumulative += normalizedProbabilities[i];
      if (random <= cumulative) {
        return unvisited[i];
      }
    }

    return unvisited[0]; // Fallback if no location selected
  }

  // Update pheromones based on the routes generated by ants
  private updatePheromones(allRoutes: [number, number][][], locations: [number, number][]): void {
    // Evaporate pheromones
    for (let i = 0; i < locations.length; i++) {
      for (let j = 0; j < locations.length; j++) {
        this.pheromones[i][j] *= (1 - this.evaporationRate);
      }
    }

    // Deposit pheromones based on route quality
    for (const route of allRoutes) {
      const distance = this.calculateTotalDistance(route);
      const pheromoneDeposit = 1 / distance;

      for (let i = 0; i < route.length - 1; i++) {
        const from = locations.indexOf(route[i]);
        const to = locations.indexOf(route[i + 1]);
        this.pheromones[from][to] += pheromoneDeposit;
        this.pheromones[to][from] += pheromoneDeposit; // Symmetric TSP
      }
    }
  }

  // Get pheromone level between two locations
  private getPheromoneLevel(
    coord1: [number, number],
    coord2: [number, number],
    locations: [number, number][]
  ): number {
    const from = locations.indexOf(coord1);
    const to = locations.indexOf(coord2);
    return this.pheromones[from][to];
  }

  // Helper method to calculate the total distance of the route
  private calculateTotalDistance(route: [number, number][], distanceCalculations?: number): number {
    let totalDistance = 0;
    for (let i = 0; i < route.length - 1; i++) {
      totalDistance += this.distanceService.calculateDistance(route[i], route[i + 1]);
      if (distanceCalculations !== undefined) {
        distanceCalculations++; // Increment distance calculations if passed in
      }
    }
    return totalDistance;
  }

}
