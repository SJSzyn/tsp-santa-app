import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class AntColonyService {
  private pheromones: number[][] = [];  // Initialize as an empty array
  public alpha: number = 1;  // Importance of pheromone
  public beta: number = 2;   // Importance of distance
  public evaporationRate: number = 0.5;
  public antCount: number = 10;  // Number of ants to simulate
  public iterations: number = 100;  // Number of iterations for optimization

  constructor() {}

  // Main method to calculate the route using the ACO algorithm
  calculateAntColonyRoute(locations: [number, number][]): [number, number][] {
    const numLocations = locations.length;
    this.initializePheromones(numLocations);

    let bestRoute: [number, number][] = [];
    let bestDistance = Infinity;

    for (let iteration = 0; iteration < this.iterations; iteration++) {
      const allRoutes: [number, number][][] = [];

      for (let ant = 0; ant < this.antCount; ant++) {
        const route = this.constructSolution(locations);
        const distance = this.calculateTotalDistance(route);

        if (distance < bestDistance) {
          bestDistance = distance;
          bestRoute = route;
        }

        allRoutes.push(route);
      }

      this.updatePheromones(allRoutes, locations);
    }

    return bestRoute;
  }

  // Initialize pheromone matrix
  private initializePheromones(numLocations: number): void {
    this.pheromones = Array.from({ length: numLocations }, () =>
      Array(numLocations).fill(1)  // Fill pheromone matrix with initial value of 1
    );
  }

  // Construct a solution for an individual ant
  private constructSolution(locations: [number, number][]): [number, number][] {
    const route: [number, number][] = [];
    const unvisited = [...locations];
    let currentLocation = unvisited.shift(); // Start from the first location

    if (currentLocation) {
      route.push(currentLocation);
    }

    while (unvisited.length > 0) {
      const nextLocation = this.selectNextLocation(currentLocation!, unvisited, locations);
      route.push(nextLocation);
      currentLocation = nextLocation;
      unvisited.splice(unvisited.indexOf(nextLocation), 1);
    }

    return route;
  }

  // Select the next location based on pheromone level and distance
  private selectNextLocation(
    currentLocation: [number, number],
    unvisited: [number, number][],
    locations: [number, number][]
  ): [number, number] {
    const probabilities = unvisited.map((location) => {
      const pheromoneLevel = this.getPheromoneLevel(currentLocation, location, locations);
      const distance = this.calculateDistance(currentLocation, location);
      return Math.pow(pheromoneLevel, this.alpha) * Math.pow(1 / distance, this.beta);
    });

    // Normalize the probabilities and select the next location
    const total = probabilities.reduce((acc, prob) => acc + prob, 0);
    const normalizedProbabilities = probabilities.map((prob) => prob / total);
    const random = Math.random();

    let cumulative = 0;
    for (let i = 0; i < normalizedProbabilities.length; i++) {
      cumulative += normalizedProbabilities[i];
      if (random <= cumulative) {
        return unvisited[i];
      }
    }

    return unvisited[0]; // Fallback if no location selected
  }

  // Update pheromones based on the routes generated by ants
  private updatePheromones(allRoutes: [number, number][][], locations: [number, number][]): void {
    // Evaporate pheromones
    for (let i = 0; i < locations.length; i++) {
      for (let j = 0; j < locations.length; j++) {
        this.pheromones[i][j] *= (1 - this.evaporationRate);
      }
    }

    // Deposit pheromones based on route quality
    for (const route of allRoutes) {
      const distance = this.calculateTotalDistance(route);
      const pheromoneDeposit = 1 / distance;

      for (let i = 0; i < route.length - 1; i++) {
        const from = locations.indexOf(route[i]);
        const to = locations.indexOf(route[i + 1]);
        this.pheromones[from][to] += pheromoneDeposit;
        this.pheromones[to][from] += pheromoneDeposit; // Symmetric TSP
      }
    }
  }

  // Get pheromone level between two locations
  private getPheromoneLevel(
    coord1: [number, number],
    coord2: [number, number],
    locations: [number, number][]
  ): number {
    const from = locations.indexOf(coord1);
    const to = locations.indexOf(coord2);
    return this.pheromones[from][to];
  }

  // Helper method to calculate the total distance of the route
  private calculateTotalDistance(route: [number, number][]): number {
    let totalDistance = 0;
    for (let i = 0; i < route.length - 1; i++) {
      totalDistance += this.calculateDistance(route[i], route[i + 1]);
    }
    return totalDistance;
  }

  // Helper method to calculate the distance between two coordinates
  private calculateDistance(coord1: [number, number], coord2: [number, number]): number {
    const R = 6371e3; // Earth's radius in meters
    const lat1 = this.toRadians(coord1[0]);
    const lat2 = this.toRadians(coord2[0]);
    const deltaLat = this.toRadians(coord2[0] - coord1[0]);
    const deltaLng = this.toRadians(coord2[1] - coord1[1]);

    const a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
      Math.cos(lat1) * Math.cos(lat2) *
      Math.sin(deltaLng / 2) * Math.sin(deltaLng / 2);

    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

    const distance = R * c;
    return distance;
  }

  private toRadians(degrees: number): number {
    return degrees * (Math.PI / 180);
  }
}
